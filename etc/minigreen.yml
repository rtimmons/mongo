
#######################################
#               Modules               #
#######################################
# if a module is added and to be added to the manifest
# be sure to add the module to git.get_project revisions parameter
modules:
- name: enterprise
  repo: git@github.com:10gen/mongo-enterprise-modules.git
  prefix: src/mongo/db/modules
  branch: master

- name: wtdevelop
  repo: git@github.com:wiredtiger/wiredtiger.git
  prefix: src/third_party
  branch: develop

variables:
# Used when the tests it runs depend only on mongod, mongos, the mongo shell and the tools.
- &task_template
  name: template
  depends_on:
  - name: compile
  commands:
  - func: "do setup"
  - func: "run tests"
    vars:
      resmoke_args: --help
      resmoke_jobs_max: 0  # No cap on number of jobs.

- &compile_task_group_template
  name: compile_task_group_template
  max_hosts: 1
  tasks: []
  setup_task:
  - func: "apply compile expansions"
  - func: "set task expansion macros"
  teardown_task:
  - func: "attach scons config log"
  - func: "attach report"
  - func: "attach artifacts"
  - func: "kill processes"
  - func: "save mongo coredumps"
  - func: "save failed unittests"
  - func: "save unstripped dbtest"
  - func: "save hang analyzer debugger files"
  - func: "save disk statistics"
  - func: "save system resource information"
  - command: shell.exec
    type: setup
    params:
      working_dir: src
      shell: bash
      script: |
        set -o verbose
        set -o errexit

        ./buildscripts/merge_corpus.sh
  - func: "archive new corpus"
  - func: "upload new corpus"
  - func: "remove files"
    vars:
      files: >-
        src/resmoke_error_code
        src/build/scons/config.log
        src/*.gcda.gcov
        src/gcov-intermediate-files.tgz
        src/*.core src/*.mdmp
        mongo-coredumps.tgz
        src/unittest_binaries/*_test${exe}
        mongo-unittests.tgz
        src/debugger*.*
        src/mongo-hanganalyzer.tgz
        diskstats.tgz
        system-resource-info.tgz
        ${report_file|src/report.json}
        ${archive_file|src/archive.json}
  setup_group_can_fail_task: true
  setup_group:
  - func: "kill processes"
  - func: "cleanup environment"
  - func: "clear OOM messages"
  - command: manifest.load
  - func: "git get project"
  - func: "get all modified patch files"
  - func: "set task expansion macros"
  # The python virtual environment is installed in ${workdir}, which is created in
  # "set up virtualenv".
  - func: "set up virtualenv"
  - func: "upload pip requirements"
  - func: "configure evergreen api credentials"
  # NOTE: To disable the compile bypass feature, comment out the next line.
  - func: "bypass compile and fetch binaries"
  - func: "update bypass expansions"
  - func: "get buildnumber"
  - func: "set up credentials"
  - func: "fetch and build OpenSSL"
  - func: "use WiredTiger develop" # noop if ${use_wt_develop} is not "true"
  - func: "set up win mount script"
  - func: "generate compile expansions"
  teardown_group:
  - func: "umount shared scons directory"
  - func: "print OOM messages"
  - func: "cleanup environment"
  timeout:
  - func: "run hang analyzer"

#######################################
#            Functions                #
#######################################

functions:
functions:

  "remove files": &remove_files
    command: shell.exec
    params:
      script: |
        if [ -z "${files}" ]; then
          exit 0
        fi
        for file in ${files}
        do
          if [ -f "$file" ]; then
            echo "Removing file $file"
            rm -f $file
          fi
        done

  "configure evergreen api credentials": &configure_evergreen_api_credentials
    command: shell.exec
    type: test
    params:
      working_dir: src
      silent: true
      script: |
        # Create the Evergreen API credentials
        cat > .evergreen.yml <<END_OF_CREDS
        api_server_host: https://evergreen.mongodb.com/api
        api_key: "${evergreen_api_key}"
        user: "${evergreen_api_user}"
        END_OF_CREDS

  "git get project": &git_get_project
    command: git.get_project
    params:
      directory: ${git_project_directory|src}
      revisions: # for each module include revision as <module_name> : ${<module_name>_rev}
        enterprise: ${enterprise_rev}
        wtdevelop: ${wtdevelop_rev}

  "fetch artifacts": &fetch_artifacts
    command: s3.get
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      remote_file: ${project}/${build_variant}/${revision}/artifacts/${build_id}.tgz
      bucket: mciuploads
      extract_to: src

  # Run a monitor process as a background, system task to periodically
  # display how many threads interesting processes are using.
  "monitor process threads": &monitor_process_threads
    command: shell.exec
    params:
      background: true
      system_log: true
      script: |
        proc_list="(bsondump|java|lein|mongo|python|_test$|_test\.exe$)"
        if [ "Windows_NT" = "$OS" ]; then
          get_pids() {
            proc_pids=$(tasklist /fo:csv |
                        awk -F'","' '{x=$1; gsub("\"","",x); print $2, x}' |
                        grep -iE $1 |
                        cut -f1 -d ' ');
          }
          get_process_info() {
            proc_name="";
            proc_info=$(wmic process where "ProcessId=\"$1\"" get "Name,ProcessId,ThreadCount" /format:csv 2> /dev/null | grep $1);
            if [ ! -z $proc_info ]; then
              proc_name=$(echo $proc_info | cut -f2 -d ',');
              proc_threads=$(echo $proc_info | cut -f4 -d ',');
            fi;
          }
        else
          get_pids() { proc_pids=$(pgrep $1); }
          get_process_info() {
            proc_name=$(ps -p $1 -o comm=);
            # /proc is available on Linux platforms
            if [ -f /proc/$1/status ]; then
              ${set_sudo}
              proc_threads=$($sudo grep Threads /proc/$1/status | sed "s/\s//g" | cut -f2 -d ":");
            else
              proc_threads=$(ps -AM $1 | grep -vc PID);
            fi;
          }
        fi
        while [ 1 ]
        do
          get_pids $proc_list
          if [ ! -z "$proc_pids" ]; then
            printf "Running process/thread counter\n"
            printf "PROCESS\tPID\tTHREADS\n"
          fi
          for pid in $proc_pids
          do
            get_process_info $pid
            if [ ! -z "$proc_name" ]; then
              printf "$proc_name\t$pid\t$proc_threads\n"
            fi
          done
          sleep 60
        done

  "collect system resource info": &collect_system_resource_info
    command: shell.exec
    params:
      working_dir: src
      background: true
      system_log: true
      script: |
        ${activate_virtualenv}
        $python buildscripts/collect_resource_info.py -o system_resource_info.json -i 5

  "run tests":
    - *determine_task_timeout
    - *update_task_timeout_expansions
    - *update_task_timeout
    - command: expansions.update
      params:
        updates:
        - key: aws_key_remote
          value: ${mongodatafiles_aws_key}
        - key: aws_profile_remote
          value: mongodata_aws
        - key: aws_secret_remote
          value: ${mongodatafiles_aws_secret}
    - *set_up_remote_credentials
    - *determine_resmoke_jobs
    - *update_resmoke_jobs_expansions
    - *execute_resmoke_tests
      # The existence of the "run_tests_infrastructure_failure" file indicates this failure isn't
      # directly actionable. We use type=setup rather than type=system or type=test for this command
      # because we don't intend for any human to look at this failure.
    - command: shell.exec
      type: setup
      params:
        working_dir: src
        script: |
          set -o verbose
          if [ -f run_tests_infrastructure_failure ]; then
            exit $(cat run_tests_infrastructure_failure)
          fi



#######################################
#            Buildvariants            #
#######################################

task_groups:
- <<: *compile_task_group_template
  name: compile_all_run_unittests_TG
  tasks:
  - compile
  - unittests
  - dbtest
  - compile_all


##########################################
# 			Tasks
##########################################

tasks:

## compile - build all scons targets except unittests ##
- name: compile
  depends_on: []
  commands:
    - func: "build new tools"
    - func: "scons compile"
      vars:
        targets: >-
          archive-dist
          archive-dist-debug
          install-core
          install-tools
          distsrc-${ext|tgz}
          ${additional_targets|}
          ${msi_target|}
          ${mh_target|}
        task_compile_flags: >-
          --use-new-tools
          --build-mongoreplay="${build_mongoreplay}"
          --detect-odr-violations
          --install-mode=hygienic
          --separate-debug
          --legacy-tarball
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o errexit
          set -o verbose

          if [ "${is_patch}" = "true" ] && [ "${bypass_compile|false}" = "true" ]; then
            exit 0
          fi

          mv mongodb-src-*.${ext|tgz} distsrc.${ext|tgz}
          mv mongodb-*-debugsymbols.${ext|tgz} mongo-debugsymbols.tgz || true
          mv mongodb-*.${ext|tgz} mongodb-binaries.tgz

    # Tar unstripped dbtest, to be archived in case of failure
    - command: archive.targz_pack
      params:
        target: "dbtest_unstripped.tgz"
        source_dir: "src"
        include:
          - "./dbtest*"

    - command: shell.exec
      params:
        working_dir: src
        script: |
          set -o errexit
          set -o verbose

          if [ "${is_patch}" = "true" ] && [ "${bypass_compile|false}" = "true" ]; then
            exit 0
          fi
          ${activate_virtualenv}
          if [ "${has_packages|}" = "true" ] ; then
            cd buildscripts
            $python ${packager_script} --prefix `pwd`/.. --distros ${packager_distro} --tarball `pwd`/../mongodb-binaries.tgz -s ${version} -m HEAD -a ${packager_arch}
            cd ..
          fi

          # Create separate shell archive
          mkdir -p shell-archive/build
          cd shell-archive
          ${platform_decompress|tar xzvf} ../mongodb-binaries.tgz
          find . -mindepth 3 ! -name "mongo${exe}" -type f -exec rm {} \; # delete bin/* except bin/mongo
          $python ../buildscripts/make_archive.py -o mongodb-shell.${ext|tgz} $(find mongodb-* -type f)
          cd ..

          # Create separate cryptd archive if mongocryptd is in the tarball
          mkdir -p cryptd-archive/build
          cd cryptd-archive
          ${platform_decompress|tar xzvf} ../mongodb-binaries.tgz
          find . -mindepth 3 ! -name "mongocryptd${exe}" -type f -exec rm {} \; # delete bin/* except bin/mongocryptd
          if [ $(find . -name mongocryptd${exe} | wc -l) -eq 1 ] ; then
            $python ../buildscripts/make_archive.py -o mongodb-cryptd.${ext|tgz} $(find mongodb-* -type f)

            # Validate that this build_variant is listed as a known enterprise task for mongocryptd
            PATH=$PATH:$HOME $python ../buildscripts/validate_mongocryptd.py --variant "${build_variant}" ../etc/evergreen.yml
          fi
          cd ..

    - command: archive.targz_pack
      params:
        target: "packages.tgz"
        source_dir: "src"
        include:
          - "repo/**"

    - command: archive.targz_pack
      params:
        target: "artifacts.tgz"
        source_dir: "src"
        include:
          - "src/mongo/db/modules/enterprise/jstests/**"
          - "compile_expansions.yml"
          - "src/mongo/db/modules/subscription/jstests/**"
          - "src/mongo/db/modules/enterprise/docs/**"
          - "*.exe"
          - "jstests/**"
          - "pytests/**"
          - "./test*"
          - "./mongobridge*"
          - "./mongotmock*"
          - "./wt*"
          - "buildscripts/**"
          - "*Example"
          - "*Test"
          - "./**.pdb"
          - "./**.msi"
          - "./etc/pip/**"
          - "./etc/scons/**"
          - "./etc/*san.suppressions"
          - "./etc/repo_config.yaml"
          - "./build/**.gcno"
          - "src/mongo/util/options_parser/test_config_files/**"
          - "src/mongo/client/sdam/json_tests/**"
          - "library_dependency_graph.json"
          - "src/third_party/JSON-Schema-Test-Suite/tests/draft4/**"
          - "src/third_party/mock_ocsp_responder/**"
          - "bypass_compile_expansions.yml"
          - "patch_files.txt"
          - "artifacts.json"
        exclude_files:
          - "*_test.pdb"

    - func: "upload debugsymbols"
    - command: s3.put
      params:
        optional: true
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: src/mongodb-binaries.tgz
        remote_file: ${mongo_binaries}
        bucket: mciuploads
        permissions: public-read
        content_type: ${content_type|application/gzip}
        display_name: Binaries
    - command: s3.put
      params:
        optional: true
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: src/cryptd-archive/mongodb-cryptd.${ext|tgz}
        remote_file: ${mongo_cryptd}
        bucket: mciuploads
        permissions: public-read
        content_type: ${content_type|application/gzip}
        display_name: CryptD Binaries
    - command: s3.put
      params:
        optional: true
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: src/mh-binaries.${ext|tgz}
        remote_file: ${mh_archive}
        bucket: mciuploads
        permissions: public-read
        content_type: ${content_type|application/gzip}
        display_name: MH Binaries
    - command: s3.put
      params:
        optional: true
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: src/mh-debugsymbols.${ext|tgz}
        remote_file: ${mh_debugsymbols}
        bucket: mciuploads
        permissions: public-read
        content_type: ${content_type|application/gzip}
        display_name: MH Debuginfo
    - command: s3.put
      params:
        optional: true
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: src/shell-archive/mongodb-shell.${ext|tgz}
        remote_file: ${mongo_shell}
        bucket: mciuploads
        permissions: public-read
        content_type: ${content_type|application/gzip}
        display_name: Shell
    - command: s3.put
      params:
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: artifacts.tgz
        remote_file: ${project}/${build_variant}/${revision}/artifacts/${build_id}.tgz
        bucket: mciuploads
        permissions: public-read
        content_type: application/tar
        display_name: Artifacts
    - command: s3.put
      params:
        optional: true
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: packages.tgz
        remote_file: ${project}/${build_variant}/${revision}/artifacts/${build_id}-packages.tgz
        bucket: mciuploads
        permissions: public-read
        content_type: application/tar
        display_name: Packages
    - command: s3.put
      params:
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: src/distsrc.${ext|tgz}
        remote_file: ${project}/${build_variant}/${revision}/sources/mongo-src-${build_id}.${ext|tgz}
        bucket: mciuploads
        permissions: public-read
        content_type: ${content_type|application/gzip}
        display_name: Source tarball
        # We only need to upload the source tarball from one of the build variants
        # because it should be the same everywhere, so just use rhel70/windows.
        build_variants: [rhel70]
    - command: s3.put
      params:
        optional: true
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: src/scons_cache.log
        content_type: text/plain
        remote_file: ${project}/${build_variant}/${revision}/scons-cache-${build_id}-${execution}.log
        bucket: mciuploads
        permissions: public-read
        display_name: SCons cache debug log
    # For patch builds that bypass compile, we upload links to pre-existing tarballs, except for the
    # artifacts.tgz.
    - command: attach.artifacts
      params:
        optional: true
        ignore_artifacts_for_spawn: false
        files:
          - src/artifacts.json

## compile_all - build all scons targets ##
- name: compile_all
  commands:
    - func: "build new tools"
    - func: "scons compile"
      vars:
        targets: all
        compiling_for_test: true
        task_compile_flags: >-
          --use-new-tools
          --build-mongoreplay="${build_mongoreplay}"
          --detect-odr-violations
    - command: s3.put
      params:
        aws_key: ${aws_key}
        aws_secret: ${aws_secret}
        local_file: src/library_dependency_graph.json
        remote_file: ${project}/${build_variant}/${revision}/library_dependency_graph.${build_id}.json
        bucket: mciuploads
        permissions: public-read
        content_type: application/json
        display_name: Library Dependency Graph (library_dependency_graph.json)
        build_variants: [enterprise-rhel-70-64-bit-kitchen-sink] # This must be the Dagger variant

## unittests - run unittests ##
- name: unittests
  commands:
    - func: "scons compile"
      vars:
        targets: unittests
        task_compile_flags: >-
          --detect-odr-violations
        compiling_for_test: true
    - func: "run diskstats"
    - func: "monitor process threads"
    - func: "collect system resource info"
    - func: "run tests"
      vars:
        resmoke_args: --suites=unittests

## dbtest ##
- name: dbtest
  commands:
    - func: "scons compile"
      vars:
        targets: dbtest
        task_compile_flags: >-
          --detect-odr-violations
        compiling_for_test: true
    # Tar unstripped dbtest, to be archived in case of failure
    - command: archive.targz_pack
      params:
        target: "dbtest_unstripped.tgz"
        source_dir: "src"
        include:
          - "./dbtest*"
    - func: "run diskstats"
    - func: "monitor process threads"
    - func: "collect system resource info"
    - func: "run tests"
      vars:
        resmoke_args: --suites=dbtest --storageEngine=wiredTiger


buildvariants:

- name: ubuntu1804-debug-aubsan-lite
  display_name: "! {A,UB}SAN Enterprise Ubuntu 18.04 DEBUG"
  batchtime: 60 # 1 hour
  modules:
  - enterprise
  run_on:
  - ubuntu1804-build
  stepback: true
  expansions:
    # We need llvm-symbolizer in the PATH for ASAN for clang-3.7 or later.
    variant_path_suffix: /opt/mongodbtoolchain/v3/bin
    lang_environment: LANG=C
    san_options: UBSAN_OPTIONS="print_stacktrace=1" LSAN_OPTIONS="suppressions=etc/lsan.suppressions:report_objects=1" ASAN_OPTIONS=detect_leaks=1:check_initialization_order=true:strict_init_order=true:abort_on_error=1:disable_coredump=0:handle_abort=1
    compile_flags: --variables-files=etc/scons/mongodbtoolchain_v3_clang.vars --dbg=on --opt=on --allocator=system --sanitize=undefined,address --ssl -j$(grep -c ^processor /proc/cpuinfo) --nostrip
    resmoke_jobs_factor: 0.3  # Avoid starting too many mongod's under {A,UB}SAN build.
    tooltags: "ssl"
    build_mongoreplay: true
    hang_analyzer_dump_core: false
    scons_cache_scope: shared
  tasks:
  - name: compile_all_run_unittests_TG
  # - name: server_discovery_and_monitoring_json_test_TG
   - name: jsCore
  # - name: jsCore_txns





